# Wireが必要な理由と配置場所の解説

## 1. Wireが必要になった背景

### **問題：手動での依存性注入が複雑**

```go
// ❌ 手動で依存性を注入する場合（Wireなし）
func main() {
    // Step 1: データベース接続
    sqlDB, err := sql.Open("postgres", "connection_string")
    if err != nil {
        panic(err)
    }

    // Step 2: DB clientを作成
    dbClient := db.NewDB(sqlDB)

    // Step 3: Query層を作成
    userQuery := query.NewUser(dbClient)
    publisherQuery := query.NewPublisher(dbClient)

    // Step 4: Repository層を作成
    userRepo := repository.NewUser(dbClient)
    publisherRepo := repository.NewPublisher(dbClient)

    // Step 5: UseCase層を作成
    userUseCase := usecase.NewUser(userQuery, userRepo)
    publisherUseCase := usecase.NewPublisher(publisherQuery, publisherRepo)

    // これが10個、20個と増えていくと...
    // 管理が大変！依存関係の順序も間違いやすい！
}
```

### **解決：Wireによる自動依存性注入**

```go
// ✅ Wireを使った場合
func main() {
    sqlDB, err := sql.Open("postgres", "connection_string")
    if err != nil {
        panic(err)
    }

    // たった1行で全ての依存性が注入される！
    userUseCase := usecase.NewUserDI(sqlDB)
    publisherUseCase := usecase.NewPublisherDI(sqlDB)

    // Wireが自動で以下を実行してくれる：
    // 1. db.NewDB(sqlDB)
    // 2. query.NewUser(dbClient)
    // 3. repository.NewUser(dbClient)
    // 4. usecase.NewUser(userQuery, userRepo)
}
```

## 2. usecase/mockにWireファイルがある理由

### **ファイル配置の全体像**

```
core/
├── usecase/
│   ├── wire.go          ← 本物のWire定義
│   ├── wire_gen.go      ← 本物のWire生成コード
│   └── mock/
│       ├── wire.go      ← モック版のWire定義（空）
│       └── wire_gen.go  ← モック版のWire生成コード（空）
```

### **なぜusecase/mockにもWireファイルがあるのか？**

#### **理由1：mockgenの仕様**

```bash
# mockgenコマンドの実行
mockgen -source /path/to/usecase/wire.go -destination /path/to/usecase/mock/wire.go
mockgen -source /path/to/usecase/wire_gen.go -destination /path/to/usecase/mock/wire_gen.go
```

- `mockgen`は**ファイル単位**でモックを生成する
- `usecase/wire.go`が存在する → `usecase/mock/wire.go`も生成される
- `usecase/wire_gen.go`が存在する → `usecase/mock/wire_gen.go`も生成される

#### **理由2：完全性の担保**

```go
// mockgenのMakefileの処理
USECASE_IFACES := $(shell find $(BACKEND_ROOT)/$(SERVICE_NAME)/usecase -maxdepth 1 -type f -name "*.go" | grep -v _test.go | grep -v _impl.go)

# 上記は「usecaseディレクトリの全ての.goファイル」を対象にする
# wire.goとwire_gen.goも含まれる
# → 自動でmock/wire.goとmock/wire_gen.goが生成される
```

#### **理由3：一貫性の維持**

```go
// もしwire.goだけモック生成をスキップすると...
usecase/
├── mock/
│   ├── mock_user.go        ← ある
│   ├── publisher.go        ← ある
│   ├── user.go            ← ある
│   ├── wire.go            ← ない！（一貫性がない）
│   └── wire_gen.go        ← ない！（一貫性がない）
```

## 3. 中身が空の理由

### **usecase/mock/wire.goの中身**

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: /Users/kima/yondeco_go/backend/core/usecase/wire.go

// Package mock_usecase is a generated GoMock package.
package mock_usecase

// ← 中身は空！
```

### **なぜ空なのか？**

#### **理由1：Wireはインターフェースではない**

```go
// wire.goの内容
func NewUserDI(*sql.DB) (_ User) {  // ← これは関数、インターフェースじゃない
    wire.Build(...)
    return
}
```

- GoMockは**インターフェース**のモックを生成する
- Wireの関数はインターフェースではない
- → モック化する必要がない → 空ファイル

#### **理由2：テストでWireは使わない**

```go
// ❌ テストでWire DIを使うことはない
func TestCreateUser(t *testing.T) {
    // これは実DBを使ってしまう
    userUseCase := usecase.NewUserDI(testDB)
}

// ✅ テストではモックを直接注入
func TestCreateUser(t *testing.T) {
    mockQuery := query_mock.NewMockUser(ctrl)
    mockRepo := repository_mock.NewMockUser(ctrl)
    userUseCase := usecase.NewUser(mockQuery, mockRepo)  // 直接注入
}
```

## 4. 初学者が混乱しやすいポイント

### **混乱ポイント1：「なぜ空ファイルを作るの？」**

**答え：** mockgenの一括処理の副作用です。必要ないけど、一貫性のために生成されています。

### **混乱ポイント2：「mockのwireファイルは使うの？」**

**答え：** 使いません。テストでは直接モックを注入します。

### **混乱ポイント3：「削除してもいいの？」**

**答え：** 削除してもテストは動きますが、`make mockgen`を実行すると再生成されます。

## 5. 実際の使い分け

### **本番・開発環境**

```go
// main.go
func main() {
    sqlDB := setupDatabase()
    
    // Wireで自動注入（実装を使用）
    userUseCase := usecase.NewUserDI(sqlDB)
    publisherUseCase := usecase.NewPublisherDI(sqlDB)
    
    // サーバー起動
}
```

### **テスト環境**

```go
// user_test.go
func TestCreateUser(t *testing.T) {
    ctrl := gomock.NewController(t)
    
    // モックを直接注入（Wireは使わない）
    mockQuery := query_mock.NewMockUser(ctrl)
    mockRepo := repository_mock.NewMockUser(ctrl)
    userUseCase := usecase.NewUser(mockQuery, mockRepo)
    
    // テスト実行
}
```

## まとめ

1. **Wire自体の目的**：複雑な依存性注入を自動化
2. **mock/wireが存在する理由**：mockgen一括処理の副作用
3. **中身が空の理由**：Wireはインターフェースじゃないのでモック不要
4. **テストでは使わない**：モックを直接注入するため
5. **削除の必要なし**：害はなく、一貫性を保つため

**一言で言うと**：usecase/mockのwireファイルは「mockgenの完全性のために存在するが、実際には使われない空ファイル」です。