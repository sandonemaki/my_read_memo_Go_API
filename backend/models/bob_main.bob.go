// Code generated by BobGen psql v0.34.2. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"hash/maphash"

	"github.com/lib/pq"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/clause"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
)

var TableNames = struct {
	Books            string
	GooseDBVersions  string
	RandokuHistories string
	RandokuImgs      string
	RandokuMemos     string
	SeidokuHistories string
	SeidokuMemos     string
	Users            string
}{
	Books:            "books",
	GooseDBVersions:  "goose_db_version",
	RandokuHistories: "randoku_histories",
	RandokuImgs:      "randoku_imgs",
	RandokuMemos:     "randoku_memos",
	SeidokuHistories: "seidoku_histories",
	SeidokuMemos:     "seidoku_memos",
	Users:            "users",
}

var ColumnNames = struct {
	Books            bookColumnNames
	GooseDBVersions  gooseDBVersionColumnNames
	RandokuHistories randokuHistoryColumnNames
	RandokuImgs      randokuImgColumnNames
	RandokuMemos     randokuMemoColumnNames
	SeidokuHistories seidokuHistoryColumnNames
	SeidokuMemos     seidokuMemoColumnNames
	Users            userColumnNames
}{
	Books: bookColumnNames{
		ID:             "id",
		Title:          "title",
		Author:         "author",
		Publisher:      "publisher",
		TotalPage:      "total_page",
		ReadingState:   "reading_state",
		CreatedAt:      "created_at",
		UpdatedAt:      "updated_at",
		SeidokuMemoKey: "seidoku_memo_key",
		CoverPath:      "cover_path",
		UserID:         "user_id",
	},
	GooseDBVersions: gooseDBVersionColumnNames{
		ID:        "id",
		VersionID: "version_id",
		IsApplied: "is_applied",
		Tstamp:    "tstamp",
	},
	RandokuHistories: randokuHistoryColumnNames{
		ID:        "id",
		Path:      "path",
		BookID:    "book_id",
		CreatedAt: "created_at",
		UpdatedAt: "updated_at",
	},
	RandokuImgs: randokuImgColumnNames{
		ID:            "id",
		FirstPostFlag: "first_post_flag",
		BookmarkFlag:  "bookmark_flag",
		Path:          "path",
		Name:          "name",
		ReadingState:  "reading_state",
		BookID:        "book_id",
		CreatedAt:     "created_at",
		UpdatedAt:     "updated_at",
		ThumbnailPath: "thumbnail_path",
	},
	RandokuMemos: randokuMemoColumnNames{
		ID:           "id",
		Content:      "content",
		ContentState: "content_state",
		BookID:       "book_id",
		CreatedAt:    "created_at",
		UpdatedAt:    "updated_at",
	},
	SeidokuHistories: seidokuHistoryColumnNames{
		ID:        "id",
		Path:      "path",
		BookID:    "book_id",
		CreatedAt: "created_at",
		UpdatedAt: "updated_at",
	},
	SeidokuMemos: seidokuMemoColumnNames{
		ID:           "id",
		Content:      "content",
		BookID:       "book_id",
		ContentState: "content_state",
		CreatedAt:    "created_at",
		UpdatedAt:    "updated_at",
	},
	Users: userColumnNames{
		ID:            "id",
		UID:           "uid",
		Nickname:      "nickname",
		DeactivatedAt: "deactivated_at",
		CreatedAt:     "created_at",
		UpdatedAt:     "updated_at",
	},
}

var (
	SelectWhere     = Where[*dialect.SelectQuery]()
	UpdateWhere     = Where[*dialect.UpdateQuery]()
	DeleteWhere     = Where[*dialect.DeleteQuery]()
	OnConflictWhere = Where[*clause.ConflictClause]() // Used in ON CONFLICT DO UPDATE
)

func Where[Q psql.Filterable]() struct {
	Books            bookWhere[Q]
	GooseDBVersions  gooseDBVersionWhere[Q]
	RandokuHistories randokuHistoryWhere[Q]
	RandokuImgs      randokuImgWhere[Q]
	RandokuMemos     randokuMemoWhere[Q]
	SeidokuHistories seidokuHistoryWhere[Q]
	SeidokuMemos     seidokuMemoWhere[Q]
	Users            userWhere[Q]
} {
	return struct {
		Books            bookWhere[Q]
		GooseDBVersions  gooseDBVersionWhere[Q]
		RandokuHistories randokuHistoryWhere[Q]
		RandokuImgs      randokuImgWhere[Q]
		RandokuMemos     randokuMemoWhere[Q]
		SeidokuHistories seidokuHistoryWhere[Q]
		SeidokuMemos     seidokuMemoWhere[Q]
		Users            userWhere[Q]
	}{
		Books:            buildBookWhere[Q](BookColumns),
		GooseDBVersions:  buildGooseDBVersionWhere[Q](GooseDBVersionColumns),
		RandokuHistories: buildRandokuHistoryWhere[Q](RandokuHistoryColumns),
		RandokuImgs:      buildRandokuImgWhere[Q](RandokuImgColumns),
		RandokuMemos:     buildRandokuMemoWhere[Q](RandokuMemoColumns),
		SeidokuHistories: buildSeidokuHistoryWhere[Q](SeidokuHistoryColumns),
		SeidokuMemos:     buildSeidokuMemoWhere[Q](SeidokuMemoColumns),
		Users:            buildUserWhere[Q](UserColumns),
	}
}

var (
	SelectJoins = getJoins[*dialect.SelectQuery]()
	UpdateJoins = getJoins[*dialect.UpdateQuery]()
	DeleteJoins = getJoins[*dialect.DeleteQuery]()
)

type joinSet[Q interface{ aliasedAs(string) Q }] struct {
	InnerJoin Q
	LeftJoin  Q
	RightJoin Q
}

func (j joinSet[Q]) AliasedAs(alias string) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: j.InnerJoin.aliasedAs(alias),
		LeftJoin:  j.LeftJoin.aliasedAs(alias),
		RightJoin: j.RightJoin.aliasedAs(alias),
	}
}

type joins[Q dialect.Joinable] struct {
	Books            joinSet[bookJoins[Q]]
	RandokuHistories joinSet[randokuHistoryJoins[Q]]
	RandokuImgs      joinSet[randokuImgJoins[Q]]
	RandokuMemos     joinSet[randokuMemoJoins[Q]]
	SeidokuHistories joinSet[seidokuHistoryJoins[Q]]
	SeidokuMemos     joinSet[seidokuMemoJoins[Q]]
	Users            joinSet[userJoins[Q]]
}

func buildJoinSet[Q interface{ aliasedAs(string) Q }, C any, F func(C, string) Q](c C, f F) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: f(c, clause.InnerJoin),
		LeftJoin:  f(c, clause.LeftJoin),
		RightJoin: f(c, clause.RightJoin),
	}
}

func getJoins[Q dialect.Joinable]() joins[Q] {
	return joins[Q]{
		Books:            buildJoinSet[bookJoins[Q]](BookColumns, buildBookJoins),
		RandokuHistories: buildJoinSet[randokuHistoryJoins[Q]](RandokuHistoryColumns, buildRandokuHistoryJoins),
		RandokuImgs:      buildJoinSet[randokuImgJoins[Q]](RandokuImgColumns, buildRandokuImgJoins),
		RandokuMemos:     buildJoinSet[randokuMemoJoins[Q]](RandokuMemoColumns, buildRandokuMemoJoins),
		SeidokuHistories: buildJoinSet[seidokuHistoryJoins[Q]](SeidokuHistoryColumns, buildSeidokuHistoryJoins),
		SeidokuMemos:     buildJoinSet[seidokuMemoJoins[Q]](SeidokuMemoColumns, buildSeidokuMemoJoins),
		Users:            buildJoinSet[userJoins[Q]](UserColumns, buildUserJoins),
	}
}

type modAs[Q any, C interface{ AliasedAs(string) C }] struct {
	c C
	f func(C) bob.Mod[Q]
}

func (m modAs[Q, C]) Apply(q Q) {
	m.f(m.c).Apply(q)
}

func (m modAs[Q, C]) AliasedAs(alias string) bob.Mod[Q] {
	m.c = m.c.AliasedAs(alias)
	return m
}

func randInt() int64 {
	out := int64(new(maphash.Hash).Sum64())

	if out < 0 {
		return -out % 10000
	}

	return out % 10000
}

// ErrUniqueConstraint captures all unique constraint errors by explicitly leaving `s` empty.
var ErrUniqueConstraint = &UniqueConstraintError{s: ""}

type UniqueConstraintError struct {
	// s is a string uniquely identifying the constraint in the raw error message returned from the database.
	s string
}

func (e *UniqueConstraintError) Error() string {
	return e.s
}

func (e *UniqueConstraintError) Is(target error) bool {
	err, ok := target.(*pq.Error)
	if !ok {
		return false
	}
	return err.Code == "23505" && (e.s == "" || err.Constraint == e.s)
}
