// Code generated by BobGen psql v0.38.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package dbmodels

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"hash/maphash"

	"github.com/lib/pq"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/clause"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/orm"
)

var TableNames = struct {
	Authors          string
	GooseDBVersions  string
	KindleHighlights string
	MasterBooks      string
	OcrTexts         string
	Publishers       string
	RandokuImages    string
	RandokuMemos     string
	ReadingHistories string
	SeidokuMemos     string
	UserBookLogs     string
	Users            string
}{
	Authors:          "authors",
	GooseDBVersions:  "goose_db_version",
	KindleHighlights: "kindle_highlights",
	MasterBooks:      "master_books",
	OcrTexts:         "ocr_texts",
	Publishers:       "publishers",
	RandokuImages:    "randoku_images",
	RandokuMemos:     "randoku_memos",
	ReadingHistories: "reading_history",
	SeidokuMemos:     "seidoku_memos",
	UserBookLogs:     "user_book_logs",
	Users:            "users",
}

var ColumnNames = struct {
	Authors          authorColumnNames
	GooseDBVersions  gooseDBVersionColumnNames
	KindleHighlights kindleHighlightColumnNames
	MasterBooks      masterBookColumnNames
	OcrTexts         ocrTextColumnNames
	Publishers       publisherColumnNames
	RandokuImages    randokuImageColumnNames
	RandokuMemos     randokuMemoColumnNames
	ReadingHistories readingHistoryColumnNames
	SeidokuMemos     seidokuMemoColumnNames
	UserBookLogs     userBookLogColumnNames
	Users            userColumnNames
}{
	Authors: authorColumnNames{
		ID:        "id",
		Name:      "name",
		CreatedAt: "created_at",
		UpdatedAt: "updated_at",
	},
	GooseDBVersions: gooseDBVersionColumnNames{
		ID:        "id",
		VersionID: "version_id",
		IsApplied: "is_applied",
		Tstamp:    "tstamp",
	},
	KindleHighlights: kindleHighlightColumnNames{
		ID:           "id",
		MasterBookID: "master_book_id",
		Position:     "position",
		Highlight:    "highlight",
		Memo:         "memo",
		LastSyncedAt: "last_synced_at",
		CreatedAt:    "created_at",
		UpdatedAt:    "updated_at",
	},
	MasterBooks: masterBookColumnNames{
		ID:          "id",
		Isbn:        "isbn",
		CoverS3URL:  "cover_s3_url",
		Title:       "title",
		AuthorID:    "author_id",
		PublisherID: "publisher_id",
		TotalPage:   "total_page",
		CreatedAt:   "created_at",
		UpdatedAt:   "updated_at",
		PublishedAt: "published_at",
	},
	OcrTexts: ocrTextColumnNames{
		ID:             "id",
		RandokuImgUlid: "randoku_img_ulid",
		Text:           "text",
		CreatedAt:      "created_at",
		UpdatedAt:      "updated_at",
	},
	Publishers: publisherColumnNames{
		ID:        "id",
		Name:      "name",
		CreatedAt: "created_at",
		UpdatedAt: "updated_at",
	},
	RandokuImages: randokuImageColumnNames{
		Ulid:           "ulid",
		MasterBookID:   "master_book_id",
		IsBookmark:     "is_bookmark",
		S3URL:          "s3_url",
		ThumbnailS3URL: "thumbnail_s3_url",
		Name:           "name",
		IsAlreadyRead:  "is_already_read",
		CreatedAt:      "created_at",
		UpdatedAt:      "updated_at",
	},
	RandokuMemos: randokuMemoColumnNames{
		ID:           "id",
		MasterBookID: "master_book_id",
		Content:      "content",
		ContentTag:   "content_tag",
		CreatedAt:    "created_at",
		UpdatedAt:    "updated_at",
	},
	ReadingHistories: readingHistoryColumnNames{
		ID:         "id",
		UserUlid:   "user_ulid",
		ContentURL: "content_url",
		RecordedAt: "recorded_at",
		CreatedAt:  "created_at",
	},
	SeidokuMemos: seidokuMemoColumnNames{
		ID:           "id",
		MasterBookID: "master_book_id",
		Content:      "content",
		ContentTag:   "content_tag",
		CreatedAt:    "created_at",
		UpdatedAt:    "updated_at",
	},
	UserBookLogs: userBookLogColumnNames{
		ID:           "id",
		UserUlid:     "user_ulid",
		MasterBookID: "master_book_id",
		Status:       "status",
		IsSeidokuKey: "is_seidoku_key",
		RegisteredAt: "registered_at",
		CreatedAt:    "created_at",
	},
	Users: userColumnNames{
		Ulid:        "ulid",
		DisplayName: "display_name",
		DeletedAt:   "deleted_at",
		CreatedAt:   "created_at",
		UpdatedAt:   "updated_at",
		UID:         "uid",
	},
}

var (
	SelectWhere     = Where[*dialect.SelectQuery]()
	UpdateWhere     = Where[*dialect.UpdateQuery]()
	DeleteWhere     = Where[*dialect.DeleteQuery]()
	OnConflictWhere = Where[*clause.ConflictClause]() // Used in ON CONFLICT DO UPDATE
)

func Where[Q psql.Filterable]() struct {
	Authors          authorWhere[Q]
	GooseDBVersions  gooseDBVersionWhere[Q]
	KindleHighlights kindleHighlightWhere[Q]
	MasterBooks      masterBookWhere[Q]
	OcrTexts         ocrTextWhere[Q]
	Publishers       publisherWhere[Q]
	RandokuImages    randokuImageWhere[Q]
	RandokuMemos     randokuMemoWhere[Q]
	ReadingHistories readingHistoryWhere[Q]
	SeidokuMemos     seidokuMemoWhere[Q]
	UserBookLogs     userBookLogWhere[Q]
	Users            userWhere[Q]
} {
	return struct {
		Authors          authorWhere[Q]
		GooseDBVersions  gooseDBVersionWhere[Q]
		KindleHighlights kindleHighlightWhere[Q]
		MasterBooks      masterBookWhere[Q]
		OcrTexts         ocrTextWhere[Q]
		Publishers       publisherWhere[Q]
		RandokuImages    randokuImageWhere[Q]
		RandokuMemos     randokuMemoWhere[Q]
		ReadingHistories readingHistoryWhere[Q]
		SeidokuMemos     seidokuMemoWhere[Q]
		UserBookLogs     userBookLogWhere[Q]
		Users            userWhere[Q]
	}{
		Authors:          buildAuthorWhere[Q](AuthorColumns),
		GooseDBVersions:  buildGooseDBVersionWhere[Q](GooseDBVersionColumns),
		KindleHighlights: buildKindleHighlightWhere[Q](KindleHighlightColumns),
		MasterBooks:      buildMasterBookWhere[Q](MasterBookColumns),
		OcrTexts:         buildOcrTextWhere[Q](OcrTextColumns),
		Publishers:       buildPublisherWhere[Q](PublisherColumns),
		RandokuImages:    buildRandokuImageWhere[Q](RandokuImageColumns),
		RandokuMemos:     buildRandokuMemoWhere[Q](RandokuMemoColumns),
		ReadingHistories: buildReadingHistoryWhere[Q](ReadingHistoryColumns),
		SeidokuMemos:     buildSeidokuMemoWhere[Q](SeidokuMemoColumns),
		UserBookLogs:     buildUserBookLogWhere[Q](UserBookLogColumns),
		Users:            buildUserWhere[Q](UserColumns),
	}
}

var Preload = getPreloaders()

type preloaders struct {
	Author          authorPreloader
	KindleHighlight kindleHighlightPreloader
	MasterBook      masterBookPreloader
	OcrText         ocrTextPreloader
	Publisher       publisherPreloader
	RandokuImage    randokuImagePreloader
	RandokuMemo     randokuMemoPreloader
	ReadingHistory  readingHistoryPreloader
	SeidokuMemo     seidokuMemoPreloader
	UserBookLog     userBookLogPreloader
	User            userPreloader
}

func getPreloaders() preloaders {
	return preloaders{
		Author:          buildAuthorPreloader(),
		KindleHighlight: buildKindleHighlightPreloader(),
		MasterBook:      buildMasterBookPreloader(),
		OcrText:         buildOcrTextPreloader(),
		Publisher:       buildPublisherPreloader(),
		RandokuImage:    buildRandokuImagePreloader(),
		RandokuMemo:     buildRandokuMemoPreloader(),
		ReadingHistory:  buildReadingHistoryPreloader(),
		SeidokuMemo:     buildSeidokuMemoPreloader(),
		UserBookLog:     buildUserBookLogPreloader(),
		User:            buildUserPreloader(),
	}
}

var (
	SelectThenLoad = getThenLoaders[*dialect.SelectQuery]()
	InsertThenLoad = getThenLoaders[*dialect.InsertQuery]()
	UpdateThenLoad = getThenLoaders[*dialect.UpdateQuery]()
)

type thenLoaders[Q orm.Loadable] struct {
	Author          authorThenLoader[Q]
	KindleHighlight kindleHighlightThenLoader[Q]
	MasterBook      masterBookThenLoader[Q]
	OcrText         ocrTextThenLoader[Q]
	Publisher       publisherThenLoader[Q]
	RandokuImage    randokuImageThenLoader[Q]
	RandokuMemo     randokuMemoThenLoader[Q]
	ReadingHistory  readingHistoryThenLoader[Q]
	SeidokuMemo     seidokuMemoThenLoader[Q]
	UserBookLog     userBookLogThenLoader[Q]
	User            userThenLoader[Q]
}

func getThenLoaders[Q orm.Loadable]() thenLoaders[Q] {
	return thenLoaders[Q]{
		Author:          buildAuthorThenLoader[Q](),
		KindleHighlight: buildKindleHighlightThenLoader[Q](),
		MasterBook:      buildMasterBookThenLoader[Q](),
		OcrText:         buildOcrTextThenLoader[Q](),
		Publisher:       buildPublisherThenLoader[Q](),
		RandokuImage:    buildRandokuImageThenLoader[Q](),
		RandokuMemo:     buildRandokuMemoThenLoader[Q](),
		ReadingHistory:  buildReadingHistoryThenLoader[Q](),
		SeidokuMemo:     buildSeidokuMemoThenLoader[Q](),
		UserBookLog:     buildUserBookLogThenLoader[Q](),
		User:            buildUserThenLoader[Q](),
	}
}

func thenLoadBuilder[Q orm.Loadable, T any](name string, f func(context.Context, bob.Executor, T, ...bob.Mod[*dialect.SelectQuery]) error) func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q] {
	return func(queryMods ...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q] {
		return orm.Loader[Q](func(ctx context.Context, exec bob.Executor, retrieved any) error {
			loader, isLoader := retrieved.(T)
			if !isLoader {
				return fmt.Errorf("object %T cannot load %q", retrieved, name)
			}

			err := f(ctx, exec, loader, queryMods...)

			// Don't cause an issue due to missing relationships
			if errors.Is(err, sql.ErrNoRows) {
				return nil
			}

			return err
		})
	}
}

var (
	SelectJoins = getJoins[*dialect.SelectQuery]()
	UpdateJoins = getJoins[*dialect.UpdateQuery]()
	DeleteJoins = getJoins[*dialect.DeleteQuery]()
)

type joinSet[Q interface{ aliasedAs(string) Q }] struct {
	InnerJoin Q
	LeftJoin  Q
	RightJoin Q
}

func (j joinSet[Q]) AliasedAs(alias string) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: j.InnerJoin.aliasedAs(alias),
		LeftJoin:  j.LeftJoin.aliasedAs(alias),
		RightJoin: j.RightJoin.aliasedAs(alias),
	}
}

type joins[Q dialect.Joinable] struct {
	Authors          joinSet[authorJoins[Q]]
	KindleHighlights joinSet[kindleHighlightJoins[Q]]
	MasterBooks      joinSet[masterBookJoins[Q]]
	OcrTexts         joinSet[ocrTextJoins[Q]]
	Publishers       joinSet[publisherJoins[Q]]
	RandokuImages    joinSet[randokuImageJoins[Q]]
	RandokuMemos     joinSet[randokuMemoJoins[Q]]
	ReadingHistories joinSet[readingHistoryJoins[Q]]
	SeidokuMemos     joinSet[seidokuMemoJoins[Q]]
	UserBookLogs     joinSet[userBookLogJoins[Q]]
	Users            joinSet[userJoins[Q]]
}

func buildJoinSet[Q interface{ aliasedAs(string) Q }, C any, F func(C, string) Q](c C, f F) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: f(c, clause.InnerJoin),
		LeftJoin:  f(c, clause.LeftJoin),
		RightJoin: f(c, clause.RightJoin),
	}
}

func getJoins[Q dialect.Joinable]() joins[Q] {
	return joins[Q]{
		Authors:          buildJoinSet[authorJoins[Q]](AuthorColumns, buildAuthorJoins),
		KindleHighlights: buildJoinSet[kindleHighlightJoins[Q]](KindleHighlightColumns, buildKindleHighlightJoins),
		MasterBooks:      buildJoinSet[masterBookJoins[Q]](MasterBookColumns, buildMasterBookJoins),
		OcrTexts:         buildJoinSet[ocrTextJoins[Q]](OcrTextColumns, buildOcrTextJoins),
		Publishers:       buildJoinSet[publisherJoins[Q]](PublisherColumns, buildPublisherJoins),
		RandokuImages:    buildJoinSet[randokuImageJoins[Q]](RandokuImageColumns, buildRandokuImageJoins),
		RandokuMemos:     buildJoinSet[randokuMemoJoins[Q]](RandokuMemoColumns, buildRandokuMemoJoins),
		ReadingHistories: buildJoinSet[readingHistoryJoins[Q]](ReadingHistoryColumns, buildReadingHistoryJoins),
		SeidokuMemos:     buildJoinSet[seidokuMemoJoins[Q]](SeidokuMemoColumns, buildSeidokuMemoJoins),
		UserBookLogs:     buildJoinSet[userBookLogJoins[Q]](UserBookLogColumns, buildUserBookLogJoins),
		Users:            buildJoinSet[userJoins[Q]](UserColumns, buildUserJoins),
	}
}

type modAs[Q any, C interface{ AliasedAs(string) C }] struct {
	c C
	f func(C) bob.Mod[Q]
}

func (m modAs[Q, C]) Apply(q Q) {
	m.f(m.c).Apply(q)
}

func (m modAs[Q, C]) AliasedAs(alias string) bob.Mod[Q] {
	m.c = m.c.AliasedAs(alias)
	return m
}

func randInt() int64 {
	out := int64(new(maphash.Hash).Sum64())

	if out < 0 {
		return -out % 10000
	}

	return out % 10000
}

// ErrUniqueConstraint captures all unique constraint errors by explicitly leaving `s` empty.
var ErrUniqueConstraint = &UniqueConstraintError{s: ""}

type UniqueConstraintError struct {
	// schema is the schema where the unique constraint is defined.
	schema string
	// table is the name of the table where the unique constraint is defined.
	table string
	// columns are the columns constituting the unique constraint.
	columns []string
	// s is a string uniquely identifying the constraint in the raw error message returned from the database.
	s string
}

func (e *UniqueConstraintError) Error() string {
	return e.s
}

func (e *UniqueConstraintError) Is(target error) bool {
	err, ok := target.(*pq.Error)
	if !ok {
		return false
	}
	return err.Code == "23505" && (e.s == "" || err.Constraint == e.s)
}
