// Code generated by BobGen psql v0.38.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package dbmodels

import (
	"context"
	"fmt"
	"io"
	"time"

	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// MasterBook is an object representing the database table.
type MasterBook struct {
	ID          int64     `db:"id,pk" `
	Isbn        string    `db:"isbn" `
	CoverS3URL  string    `db:"cover_s3_url" `
	Title       string    `db:"title" `
	AuthorID    int64     `db:"author_id" `
	PublisherID int64     `db:"publisher_id" `
	TotalPage   int32     `db:"total_page" `
	CreatedAt   time.Time `db:"created_at" `
	UpdatedAt   time.Time `db:"updated_at" `
	PublishedAt time.Time `db:"published_at" `

	R masterBookR `db:"-" `
}

// MasterBookSlice is an alias for a slice of pointers to MasterBook.
// This should almost always be used instead of []*MasterBook.
type MasterBookSlice []*MasterBook

// MasterBooks contains methods to work with the master_books table
var MasterBooks = psql.NewTablex[*MasterBook, MasterBookSlice, *MasterBookSetter]("", "master_books")

// MasterBooksQuery is a query on the master_books table
type MasterBooksQuery = *psql.ViewQuery[*MasterBook, MasterBookSlice]

// masterBookR is where relationships are stored.
type masterBookR struct {
	KindleHighlights KindleHighlightSlice // kindle_highlights.kindle_highlights_master_book_id_fkey
	Author           *Author              // master_books.master_books_author_id_fkey
	Publisher        *Publisher           // master_books.master_books_publisher_id_fkey
	RandokuImages    RandokuImageSlice    // randoku_images.randoku_images_master_book_id_fkey
	RandokuMemos     RandokuMemoSlice     // randoku_memos.randoku_memos_master_book_id_fkey
	SeidokuMemos     SeidokuMemoSlice     // seidoku_memos.seidoku_memos_master_book_id_fkey
	UserBookLogs     UserBookLogSlice     // user_book_logs.user_book_logs_master_book_id_fkey
}

type masterBookColumnNames struct {
	ID          string
	Isbn        string
	CoverS3URL  string
	Title       string
	AuthorID    string
	PublisherID string
	TotalPage   string
	CreatedAt   string
	UpdatedAt   string
	PublishedAt string
}

var MasterBookColumns = buildMasterBookColumns("master_books")

type masterBookColumns struct {
	tableAlias  string
	ID          psql.Expression
	Isbn        psql.Expression
	CoverS3URL  psql.Expression
	Title       psql.Expression
	AuthorID    psql.Expression
	PublisherID psql.Expression
	TotalPage   psql.Expression
	CreatedAt   psql.Expression
	UpdatedAt   psql.Expression
	PublishedAt psql.Expression
}

func (c masterBookColumns) Alias() string {
	return c.tableAlias
}

func (masterBookColumns) AliasedAs(alias string) masterBookColumns {
	return buildMasterBookColumns(alias)
}

func buildMasterBookColumns(alias string) masterBookColumns {
	return masterBookColumns{
		tableAlias:  alias,
		ID:          psql.Quote(alias, "id"),
		Isbn:        psql.Quote(alias, "isbn"),
		CoverS3URL:  psql.Quote(alias, "cover_s3_url"),
		Title:       psql.Quote(alias, "title"),
		AuthorID:    psql.Quote(alias, "author_id"),
		PublisherID: psql.Quote(alias, "publisher_id"),
		TotalPage:   psql.Quote(alias, "total_page"),
		CreatedAt:   psql.Quote(alias, "created_at"),
		UpdatedAt:   psql.Quote(alias, "updated_at"),
		PublishedAt: psql.Quote(alias, "published_at"),
	}
}

type masterBookWhere[Q psql.Filterable] struct {
	ID          psql.WhereMod[Q, int64]
	Isbn        psql.WhereMod[Q, string]
	CoverS3URL  psql.WhereMod[Q, string]
	Title       psql.WhereMod[Q, string]
	AuthorID    psql.WhereMod[Q, int64]
	PublisherID psql.WhereMod[Q, int64]
	TotalPage   psql.WhereMod[Q, int32]
	CreatedAt   psql.WhereMod[Q, time.Time]
	UpdatedAt   psql.WhereMod[Q, time.Time]
	PublishedAt psql.WhereMod[Q, time.Time]
}

func (masterBookWhere[Q]) AliasedAs(alias string) masterBookWhere[Q] {
	return buildMasterBookWhere[Q](buildMasterBookColumns(alias))
}

func buildMasterBookWhere[Q psql.Filterable](cols masterBookColumns) masterBookWhere[Q] {
	return masterBookWhere[Q]{
		ID:          psql.Where[Q, int64](cols.ID),
		Isbn:        psql.Where[Q, string](cols.Isbn),
		CoverS3URL:  psql.Where[Q, string](cols.CoverS3URL),
		Title:       psql.Where[Q, string](cols.Title),
		AuthorID:    psql.Where[Q, int64](cols.AuthorID),
		PublisherID: psql.Where[Q, int64](cols.PublisherID),
		TotalPage:   psql.Where[Q, int32](cols.TotalPage),
		CreatedAt:   psql.Where[Q, time.Time](cols.CreatedAt),
		UpdatedAt:   psql.Where[Q, time.Time](cols.UpdatedAt),
		PublishedAt: psql.Where[Q, time.Time](cols.PublishedAt),
	}
}

var MasterBookErrors = &masterBookErrors{
	ErrUniqueMasterBooksPkey: &UniqueConstraintError{
		schema:  "",
		table:   "master_books",
		columns: []string{"id"},
		s:       "master_books_pkey",
	},
}

type masterBookErrors struct {
	ErrUniqueMasterBooksPkey *UniqueConstraintError
}

// MasterBookSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type MasterBookSetter struct {
	ID          *int64     `db:"id,pk" `
	Isbn        *string    `db:"isbn" `
	CoverS3URL  *string    `db:"cover_s3_url" `
	Title       *string    `db:"title" `
	AuthorID    *int64     `db:"author_id" `
	PublisherID *int64     `db:"publisher_id" `
	TotalPage   *int32     `db:"total_page" `
	CreatedAt   *time.Time `db:"created_at" `
	UpdatedAt   *time.Time `db:"updated_at" `
	PublishedAt *time.Time `db:"published_at" `
}

func (s MasterBookSetter) SetColumns() []string {
	vals := make([]string, 0, 10)
	if s.ID != nil {
		vals = append(vals, "id")
	}

	if s.Isbn != nil {
		vals = append(vals, "isbn")
	}

	if s.CoverS3URL != nil {
		vals = append(vals, "cover_s3_url")
	}

	if s.Title != nil {
		vals = append(vals, "title")
	}

	if s.AuthorID != nil {
		vals = append(vals, "author_id")
	}

	if s.PublisherID != nil {
		vals = append(vals, "publisher_id")
	}

	if s.TotalPage != nil {
		vals = append(vals, "total_page")
	}

	if s.CreatedAt != nil {
		vals = append(vals, "created_at")
	}

	if s.UpdatedAt != nil {
		vals = append(vals, "updated_at")
	}

	if s.PublishedAt != nil {
		vals = append(vals, "published_at")
	}

	return vals
}

func (s MasterBookSetter) Overwrite(t *MasterBook) {
	if s.ID != nil {
		t.ID = *s.ID
	}
	if s.Isbn != nil {
		t.Isbn = *s.Isbn
	}
	if s.CoverS3URL != nil {
		t.CoverS3URL = *s.CoverS3URL
	}
	if s.Title != nil {
		t.Title = *s.Title
	}
	if s.AuthorID != nil {
		t.AuthorID = *s.AuthorID
	}
	if s.PublisherID != nil {
		t.PublisherID = *s.PublisherID
	}
	if s.TotalPage != nil {
		t.TotalPage = *s.TotalPage
	}
	if s.CreatedAt != nil {
		t.CreatedAt = *s.CreatedAt
	}
	if s.UpdatedAt != nil {
		t.UpdatedAt = *s.UpdatedAt
	}
	if s.PublishedAt != nil {
		t.PublishedAt = *s.PublishedAt
	}
}

func (s *MasterBookSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return MasterBooks.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 10)
		if s.ID != nil {
			vals[0] = psql.Arg(*s.ID)
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if s.Isbn != nil {
			vals[1] = psql.Arg(*s.Isbn)
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if s.CoverS3URL != nil {
			vals[2] = psql.Arg(*s.CoverS3URL)
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if s.Title != nil {
			vals[3] = psql.Arg(*s.Title)
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if s.AuthorID != nil {
			vals[4] = psql.Arg(*s.AuthorID)
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if s.PublisherID != nil {
			vals[5] = psql.Arg(*s.PublisherID)
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if s.TotalPage != nil {
			vals[6] = psql.Arg(*s.TotalPage)
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if s.CreatedAt != nil {
			vals[7] = psql.Arg(*s.CreatedAt)
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if s.UpdatedAt != nil {
			vals[8] = psql.Arg(*s.UpdatedAt)
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if s.PublishedAt != nil {
			vals[9] = psql.Arg(*s.PublishedAt)
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s MasterBookSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s MasterBookSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 10)

	if s.ID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "id")...),
			psql.Arg(s.ID),
		}})
	}

	if s.Isbn != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "isbn")...),
			psql.Arg(s.Isbn),
		}})
	}

	if s.CoverS3URL != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "cover_s3_url")...),
			psql.Arg(s.CoverS3URL),
		}})
	}

	if s.Title != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "title")...),
			psql.Arg(s.Title),
		}})
	}

	if s.AuthorID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "author_id")...),
			psql.Arg(s.AuthorID),
		}})
	}

	if s.PublisherID != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "publisher_id")...),
			psql.Arg(s.PublisherID),
		}})
	}

	if s.TotalPage != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "total_page")...),
			psql.Arg(s.TotalPage),
		}})
	}

	if s.CreatedAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_at")...),
			psql.Arg(s.CreatedAt),
		}})
	}

	if s.UpdatedAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "updated_at")...),
			psql.Arg(s.UpdatedAt),
		}})
	}

	if s.PublishedAt != nil {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "published_at")...),
			psql.Arg(s.PublishedAt),
		}})
	}

	return exprs
}

// FindMasterBook retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindMasterBook(ctx context.Context, exec bob.Executor, IDPK int64, cols ...string) (*MasterBook, error) {
	if len(cols) == 0 {
		return MasterBooks.Query(
			SelectWhere.MasterBooks.ID.EQ(IDPK),
		).One(ctx, exec)
	}

	return MasterBooks.Query(
		SelectWhere.MasterBooks.ID.EQ(IDPK),
		sm.Columns(MasterBooks.Columns().Only(cols...)),
	).One(ctx, exec)
}

// MasterBookExists checks the presence of a single record by primary key
func MasterBookExists(ctx context.Context, exec bob.Executor, IDPK int64) (bool, error) {
	return MasterBooks.Query(
		SelectWhere.MasterBooks.ID.EQ(IDPK),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after MasterBook is retrieved from the database
func (o *MasterBook) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = MasterBooks.AfterSelectHooks.RunHooks(ctx, exec, MasterBookSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = MasterBooks.AfterInsertHooks.RunHooks(ctx, exec, MasterBookSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = MasterBooks.AfterUpdateHooks.RunHooks(ctx, exec, MasterBookSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = MasterBooks.AfterDeleteHooks.RunHooks(ctx, exec, MasterBookSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the MasterBook
func (o *MasterBook) primaryKeyVals() bob.Expression {
	return psql.Arg(o.ID)
}

func (o *MasterBook) pkEQ() dialect.Expression {
	return psql.Quote("master_books", "id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the MasterBook
func (o *MasterBook) Update(ctx context.Context, exec bob.Executor, s *MasterBookSetter) error {
	v, err := MasterBooks.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single MasterBook record with an executor
func (o *MasterBook) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := MasterBooks.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the MasterBook using the executor
func (o *MasterBook) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := MasterBooks.Query(
		SelectWhere.MasterBooks.ID.EQ(o.ID),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after MasterBookSlice is retrieved from the database
func (o MasterBookSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = MasterBooks.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = MasterBooks.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = MasterBooks.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = MasterBooks.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o MasterBookSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("master_books", "id").In(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o MasterBookSlice) copyMatchingRows(from ...*MasterBook) {
	for i, old := range o {
		for _, new := range from {
			if new.ID != old.ID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o MasterBookSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return MasterBooks.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *MasterBook:
				o.copyMatchingRows(retrieved)
			case []*MasterBook:
				o.copyMatchingRows(retrieved...)
			case MasterBookSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a MasterBook or a slice of MasterBook
				// then run the AfterUpdateHooks on the slice
				_, err = MasterBooks.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o MasterBookSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return MasterBooks.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *MasterBook:
				o.copyMatchingRows(retrieved)
			case []*MasterBook:
				o.copyMatchingRows(retrieved...)
			case MasterBookSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a MasterBook or a slice of MasterBook
				// then run the AfterDeleteHooks on the slice
				_, err = MasterBooks.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o MasterBookSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals MasterBookSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := MasterBooks.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o MasterBookSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := MasterBooks.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o MasterBookSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := MasterBooks.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

type masterBookJoins[Q dialect.Joinable] struct {
	typ              string
	KindleHighlights modAs[Q, kindleHighlightColumns]
	Author           modAs[Q, authorColumns]
	Publisher        modAs[Q, publisherColumns]
	RandokuImages    modAs[Q, randokuImageColumns]
	RandokuMemos     modAs[Q, randokuMemoColumns]
	SeidokuMemos     modAs[Q, seidokuMemoColumns]
	UserBookLogs     modAs[Q, userBookLogColumns]
}

func (j masterBookJoins[Q]) aliasedAs(alias string) masterBookJoins[Q] {
	return buildMasterBookJoins[Q](buildMasterBookColumns(alias), j.typ)
}

func buildMasterBookJoins[Q dialect.Joinable](cols masterBookColumns, typ string) masterBookJoins[Q] {
	return masterBookJoins[Q]{
		typ: typ,
		KindleHighlights: modAs[Q, kindleHighlightColumns]{
			c: KindleHighlightColumns,
			f: func(to kindleHighlightColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, KindleHighlights.Name().As(to.Alias())).On(
						to.MasterBookID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Author: modAs[Q, authorColumns]{
			c: AuthorColumns,
			f: func(to authorColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Authors.Name().As(to.Alias())).On(
						to.ID.EQ(cols.AuthorID),
					))
				}

				return mods
			},
		},
		Publisher: modAs[Q, publisherColumns]{
			c: PublisherColumns,
			f: func(to publisherColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Publishers.Name().As(to.Alias())).On(
						to.ID.EQ(cols.PublisherID),
					))
				}

				return mods
			},
		},
		RandokuImages: modAs[Q, randokuImageColumns]{
			c: RandokuImageColumns,
			f: func(to randokuImageColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, RandokuImages.Name().As(to.Alias())).On(
						to.MasterBookID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		RandokuMemos: modAs[Q, randokuMemoColumns]{
			c: RandokuMemoColumns,
			f: func(to randokuMemoColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, RandokuMemos.Name().As(to.Alias())).On(
						to.MasterBookID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		SeidokuMemos: modAs[Q, seidokuMemoColumns]{
			c: SeidokuMemoColumns,
			f: func(to seidokuMemoColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, SeidokuMemos.Name().As(to.Alias())).On(
						to.MasterBookID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		UserBookLogs: modAs[Q, userBookLogColumns]{
			c: UserBookLogColumns,
			f: func(to userBookLogColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, UserBookLogs.Name().As(to.Alias())).On(
						to.MasterBookID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
	}
}

// KindleHighlights starts a query for related objects on kindle_highlights
func (o *MasterBook) KindleHighlights(mods ...bob.Mod[*dialect.SelectQuery]) KindleHighlightsQuery {
	return KindleHighlights.Query(append(mods,
		sm.Where(KindleHighlightColumns.MasterBookID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os MasterBookSlice) KindleHighlights(mods ...bob.Mod[*dialect.SelectQuery]) KindleHighlightsQuery {
	pkID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkID[i] = o.ID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "bigint[]")),
	))

	return KindleHighlights.Query(append(mods,
		sm.Where(psql.Group(KindleHighlightColumns.MasterBookID).OP("IN", PKArgExpr)),
	)...)
}

// Author starts a query for related objects on authors
func (o *MasterBook) Author(mods ...bob.Mod[*dialect.SelectQuery]) AuthorsQuery {
	return Authors.Query(append(mods,
		sm.Where(AuthorColumns.ID.EQ(psql.Arg(o.AuthorID))),
	)...)
}

func (os MasterBookSlice) Author(mods ...bob.Mod[*dialect.SelectQuery]) AuthorsQuery {
	pkAuthorID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkAuthorID[i] = o.AuthorID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkAuthorID), "bigint[]")),
	))

	return Authors.Query(append(mods,
		sm.Where(psql.Group(AuthorColumns.ID).OP("IN", PKArgExpr)),
	)...)
}

// Publisher starts a query for related objects on publishers
func (o *MasterBook) Publisher(mods ...bob.Mod[*dialect.SelectQuery]) PublishersQuery {
	return Publishers.Query(append(mods,
		sm.Where(PublisherColumns.ID.EQ(psql.Arg(o.PublisherID))),
	)...)
}

func (os MasterBookSlice) Publisher(mods ...bob.Mod[*dialect.SelectQuery]) PublishersQuery {
	pkPublisherID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkPublisherID[i] = o.PublisherID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkPublisherID), "bigint[]")),
	))

	return Publishers.Query(append(mods,
		sm.Where(psql.Group(PublisherColumns.ID).OP("IN", PKArgExpr)),
	)...)
}

// RandokuImages starts a query for related objects on randoku_images
func (o *MasterBook) RandokuImages(mods ...bob.Mod[*dialect.SelectQuery]) RandokuImagesQuery {
	return RandokuImages.Query(append(mods,
		sm.Where(RandokuImageColumns.MasterBookID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os MasterBookSlice) RandokuImages(mods ...bob.Mod[*dialect.SelectQuery]) RandokuImagesQuery {
	pkID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkID[i] = o.ID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "bigint[]")),
	))

	return RandokuImages.Query(append(mods,
		sm.Where(psql.Group(RandokuImageColumns.MasterBookID).OP("IN", PKArgExpr)),
	)...)
}

// RandokuMemos starts a query for related objects on randoku_memos
func (o *MasterBook) RandokuMemos(mods ...bob.Mod[*dialect.SelectQuery]) RandokuMemosQuery {
	return RandokuMemos.Query(append(mods,
		sm.Where(RandokuMemoColumns.MasterBookID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os MasterBookSlice) RandokuMemos(mods ...bob.Mod[*dialect.SelectQuery]) RandokuMemosQuery {
	pkID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkID[i] = o.ID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "bigint[]")),
	))

	return RandokuMemos.Query(append(mods,
		sm.Where(psql.Group(RandokuMemoColumns.MasterBookID).OP("IN", PKArgExpr)),
	)...)
}

// SeidokuMemos starts a query for related objects on seidoku_memos
func (o *MasterBook) SeidokuMemos(mods ...bob.Mod[*dialect.SelectQuery]) SeidokuMemosQuery {
	return SeidokuMemos.Query(append(mods,
		sm.Where(SeidokuMemoColumns.MasterBookID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os MasterBookSlice) SeidokuMemos(mods ...bob.Mod[*dialect.SelectQuery]) SeidokuMemosQuery {
	pkID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkID[i] = o.ID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "bigint[]")),
	))

	return SeidokuMemos.Query(append(mods,
		sm.Where(psql.Group(SeidokuMemoColumns.MasterBookID).OP("IN", PKArgExpr)),
	)...)
}

// UserBookLogs starts a query for related objects on user_book_logs
func (o *MasterBook) UserBookLogs(mods ...bob.Mod[*dialect.SelectQuery]) UserBookLogsQuery {
	return UserBookLogs.Query(append(mods,
		sm.Where(UserBookLogColumns.MasterBookID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os MasterBookSlice) UserBookLogs(mods ...bob.Mod[*dialect.SelectQuery]) UserBookLogsQuery {
	pkID := make(pgtypes.Array[int64], len(os))
	for i, o := range os {
		pkID[i] = o.ID
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "bigint[]")),
	))

	return UserBookLogs.Query(append(mods,
		sm.Where(psql.Group(UserBookLogColumns.MasterBookID).OP("IN", PKArgExpr)),
	)...)
}

func (o *MasterBook) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "KindleHighlights":
		rels, ok := retrieved.(KindleHighlightSlice)
		if !ok {
			return fmt.Errorf("masterBook cannot load %T as %q", retrieved, name)
		}

		o.R.KindleHighlights = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.MasterBook = o
			}
		}
		return nil
	case "Author":
		rel, ok := retrieved.(*Author)
		if !ok {
			return fmt.Errorf("masterBook cannot load %T as %q", retrieved, name)
		}

		o.R.Author = rel

		if rel != nil {
			rel.R.MasterBooks = MasterBookSlice{o}
		}
		return nil
	case "Publisher":
		rel, ok := retrieved.(*Publisher)
		if !ok {
			return fmt.Errorf("masterBook cannot load %T as %q", retrieved, name)
		}

		o.R.Publisher = rel

		if rel != nil {
			rel.R.MasterBooks = MasterBookSlice{o}
		}
		return nil
	case "RandokuImages":
		rels, ok := retrieved.(RandokuImageSlice)
		if !ok {
			return fmt.Errorf("masterBook cannot load %T as %q", retrieved, name)
		}

		o.R.RandokuImages = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.MasterBook = o
			}
		}
		return nil
	case "RandokuMemos":
		rels, ok := retrieved.(RandokuMemoSlice)
		if !ok {
			return fmt.Errorf("masterBook cannot load %T as %q", retrieved, name)
		}

		o.R.RandokuMemos = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.MasterBook = o
			}
		}
		return nil
	case "SeidokuMemos":
		rels, ok := retrieved.(SeidokuMemoSlice)
		if !ok {
			return fmt.Errorf("masterBook cannot load %T as %q", retrieved, name)
		}

		o.R.SeidokuMemos = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.MasterBook = o
			}
		}
		return nil
	case "UserBookLogs":
		rels, ok := retrieved.(UserBookLogSlice)
		if !ok {
			return fmt.Errorf("masterBook cannot load %T as %q", retrieved, name)
		}

		o.R.UserBookLogs = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.MasterBook = o
			}
		}
		return nil
	default:
		return fmt.Errorf("masterBook has no relationship %q", name)
	}
}

type masterBookPreloader struct {
	Author    func(...psql.PreloadOption) psql.Preloader
	Publisher func(...psql.PreloadOption) psql.Preloader
}

func buildMasterBookPreloader() masterBookPreloader {
	return masterBookPreloader{
		Author: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Author, AuthorSlice](orm.Relationship{
				Name: "Author",
				Sides: []orm.RelSide{
					{
						From: TableNames.MasterBooks,
						To:   TableNames.Authors,
						FromColumns: []string{
							ColumnNames.MasterBooks.AuthorID,
						},
						ToColumns: []string{
							ColumnNames.Authors.ID,
						},
					},
				},
			}, Authors.Columns().Names(), opts...)
		},
		Publisher: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Publisher, PublisherSlice](orm.Relationship{
				Name: "Publisher",
				Sides: []orm.RelSide{
					{
						From: TableNames.MasterBooks,
						To:   TableNames.Publishers,
						FromColumns: []string{
							ColumnNames.MasterBooks.PublisherID,
						},
						ToColumns: []string{
							ColumnNames.Publishers.ID,
						},
					},
				},
			}, Publishers.Columns().Names(), opts...)
		},
	}
}

type masterBookThenLoader[Q orm.Loadable] struct {
	KindleHighlights func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Author           func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Publisher        func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	RandokuImages    func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	RandokuMemos     func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	SeidokuMemos     func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	UserBookLogs     func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildMasterBookThenLoader[Q orm.Loadable]() masterBookThenLoader[Q] {
	type KindleHighlightsLoadInterface interface {
		LoadKindleHighlights(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type AuthorLoadInterface interface {
		LoadAuthor(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PublisherLoadInterface interface {
		LoadPublisher(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type RandokuImagesLoadInterface interface {
		LoadRandokuImages(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type RandokuMemosLoadInterface interface {
		LoadRandokuMemos(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type SeidokuMemosLoadInterface interface {
		LoadSeidokuMemos(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type UserBookLogsLoadInterface interface {
		LoadUserBookLogs(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return masterBookThenLoader[Q]{
		KindleHighlights: thenLoadBuilder[Q](
			"KindleHighlights",
			func(ctx context.Context, exec bob.Executor, retrieved KindleHighlightsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadKindleHighlights(ctx, exec, mods...)
			},
		),
		Author: thenLoadBuilder[Q](
			"Author",
			func(ctx context.Context, exec bob.Executor, retrieved AuthorLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadAuthor(ctx, exec, mods...)
			},
		),
		Publisher: thenLoadBuilder[Q](
			"Publisher",
			func(ctx context.Context, exec bob.Executor, retrieved PublisherLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadPublisher(ctx, exec, mods...)
			},
		),
		RandokuImages: thenLoadBuilder[Q](
			"RandokuImages",
			func(ctx context.Context, exec bob.Executor, retrieved RandokuImagesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadRandokuImages(ctx, exec, mods...)
			},
		),
		RandokuMemos: thenLoadBuilder[Q](
			"RandokuMemos",
			func(ctx context.Context, exec bob.Executor, retrieved RandokuMemosLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadRandokuMemos(ctx, exec, mods...)
			},
		),
		SeidokuMemos: thenLoadBuilder[Q](
			"SeidokuMemos",
			func(ctx context.Context, exec bob.Executor, retrieved SeidokuMemosLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadSeidokuMemos(ctx, exec, mods...)
			},
		),
		UserBookLogs: thenLoadBuilder[Q](
			"UserBookLogs",
			func(ctx context.Context, exec bob.Executor, retrieved UserBookLogsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadUserBookLogs(ctx, exec, mods...)
			},
		),
	}
}

// LoadKindleHighlights loads the masterBook's KindleHighlights into the .R struct
func (o *MasterBook) LoadKindleHighlights(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.KindleHighlights = nil

	related, err := o.KindleHighlights(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.MasterBook = o
	}

	o.R.KindleHighlights = related
	return nil
}

// LoadKindleHighlights loads the masterBook's KindleHighlights into the .R struct
func (os MasterBookSlice) LoadKindleHighlights(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	kindleHighlights, err := os.KindleHighlights(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.KindleHighlights = nil
	}

	for _, o := range os {
		for _, rel := range kindleHighlights {
			if o.ID != rel.MasterBookID {
				continue
			}

			rel.R.MasterBook = o

			o.R.KindleHighlights = append(o.R.KindleHighlights, rel)
		}
	}

	return nil
}

// LoadAuthor loads the masterBook's Author into the .R struct
func (o *MasterBook) LoadAuthor(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Author = nil

	related, err := o.Author(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.MasterBooks = MasterBookSlice{o}

	o.R.Author = related
	return nil
}

// LoadAuthor loads the masterBook's Author into the .R struct
func (os MasterBookSlice) LoadAuthor(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	authors, err := os.Author(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range authors {
			if o.AuthorID != rel.ID {
				continue
			}

			rel.R.MasterBooks = append(rel.R.MasterBooks, o)

			o.R.Author = rel
			break
		}
	}

	return nil
}

// LoadPublisher loads the masterBook's Publisher into the .R struct
func (o *MasterBook) LoadPublisher(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Publisher = nil

	related, err := o.Publisher(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.MasterBooks = MasterBookSlice{o}

	o.R.Publisher = related
	return nil
}

// LoadPublisher loads the masterBook's Publisher into the .R struct
func (os MasterBookSlice) LoadPublisher(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	publishers, err := os.Publisher(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range publishers {
			if o.PublisherID != rel.ID {
				continue
			}

			rel.R.MasterBooks = append(rel.R.MasterBooks, o)

			o.R.Publisher = rel
			break
		}
	}

	return nil
}

// LoadRandokuImages loads the masterBook's RandokuImages into the .R struct
func (o *MasterBook) LoadRandokuImages(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.RandokuImages = nil

	related, err := o.RandokuImages(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.MasterBook = o
	}

	o.R.RandokuImages = related
	return nil
}

// LoadRandokuImages loads the masterBook's RandokuImages into the .R struct
func (os MasterBookSlice) LoadRandokuImages(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	randokuImages, err := os.RandokuImages(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.RandokuImages = nil
	}

	for _, o := range os {
		for _, rel := range randokuImages {
			if o.ID != rel.MasterBookID {
				continue
			}

			rel.R.MasterBook = o

			o.R.RandokuImages = append(o.R.RandokuImages, rel)
		}
	}

	return nil
}

// LoadRandokuMemos loads the masterBook's RandokuMemos into the .R struct
func (o *MasterBook) LoadRandokuMemos(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.RandokuMemos = nil

	related, err := o.RandokuMemos(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.MasterBook = o
	}

	o.R.RandokuMemos = related
	return nil
}

// LoadRandokuMemos loads the masterBook's RandokuMemos into the .R struct
func (os MasterBookSlice) LoadRandokuMemos(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	randokuMemos, err := os.RandokuMemos(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.RandokuMemos = nil
	}

	for _, o := range os {
		for _, rel := range randokuMemos {
			if o.ID != rel.MasterBookID {
				continue
			}

			rel.R.MasterBook = o

			o.R.RandokuMemos = append(o.R.RandokuMemos, rel)
		}
	}

	return nil
}

// LoadSeidokuMemos loads the masterBook's SeidokuMemos into the .R struct
func (o *MasterBook) LoadSeidokuMemos(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.SeidokuMemos = nil

	related, err := o.SeidokuMemos(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.MasterBook = o
	}

	o.R.SeidokuMemos = related
	return nil
}

// LoadSeidokuMemos loads the masterBook's SeidokuMemos into the .R struct
func (os MasterBookSlice) LoadSeidokuMemos(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	seidokuMemos, err := os.SeidokuMemos(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.SeidokuMemos = nil
	}

	for _, o := range os {
		for _, rel := range seidokuMemos {
			if o.ID != rel.MasterBookID {
				continue
			}

			rel.R.MasterBook = o

			o.R.SeidokuMemos = append(o.R.SeidokuMemos, rel)
		}
	}

	return nil
}

// LoadUserBookLogs loads the masterBook's UserBookLogs into the .R struct
func (o *MasterBook) LoadUserBookLogs(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.UserBookLogs = nil

	related, err := o.UserBookLogs(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.MasterBook = o
	}

	o.R.UserBookLogs = related
	return nil
}

// LoadUserBookLogs loads the masterBook's UserBookLogs into the .R struct
func (os MasterBookSlice) LoadUserBookLogs(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	userBookLogs, err := os.UserBookLogs(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		o.R.UserBookLogs = nil
	}

	for _, o := range os {
		for _, rel := range userBookLogs {
			if o.ID != rel.MasterBookID {
				continue
			}

			rel.R.MasterBook = o

			o.R.UserBookLogs = append(o.R.UserBookLogs, rel)
		}
	}

	return nil
}

func insertMasterBookKindleHighlights0(ctx context.Context, exec bob.Executor, kindleHighlights1 []*KindleHighlightSetter, masterBook0 *MasterBook) (KindleHighlightSlice, error) {
	for i := range kindleHighlights1 {
		kindleHighlights1[i].MasterBookID = &masterBook0.ID
	}

	ret, err := KindleHighlights.Insert(bob.ToMods(kindleHighlights1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertMasterBookKindleHighlights0: %w", err)
	}

	return ret, nil
}

func attachMasterBookKindleHighlights0(ctx context.Context, exec bob.Executor, count int, kindleHighlights1 KindleHighlightSlice, masterBook0 *MasterBook) (KindleHighlightSlice, error) {
	setter := &KindleHighlightSetter{
		MasterBookID: &masterBook0.ID,
	}

	err := kindleHighlights1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachMasterBookKindleHighlights0: %w", err)
	}

	return kindleHighlights1, nil
}

func (masterBook0 *MasterBook) InsertKindleHighlights(ctx context.Context, exec bob.Executor, related ...*KindleHighlightSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	kindleHighlights1, err := insertMasterBookKindleHighlights0(ctx, exec, related, masterBook0)
	if err != nil {
		return err
	}

	masterBook0.R.KindleHighlights = append(masterBook0.R.KindleHighlights, kindleHighlights1...)

	for _, rel := range kindleHighlights1 {
		rel.R.MasterBook = masterBook0
	}
	return nil
}

func (masterBook0 *MasterBook) AttachKindleHighlights(ctx context.Context, exec bob.Executor, related ...*KindleHighlight) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	kindleHighlights1 := KindleHighlightSlice(related)

	_, err = attachMasterBookKindleHighlights0(ctx, exec, len(related), kindleHighlights1, masterBook0)
	if err != nil {
		return err
	}

	masterBook0.R.KindleHighlights = append(masterBook0.R.KindleHighlights, kindleHighlights1...)

	for _, rel := range related {
		rel.R.MasterBook = masterBook0
	}

	return nil
}

func attachMasterBookAuthor0(ctx context.Context, exec bob.Executor, count int, masterBook0 *MasterBook, author1 *Author) (*MasterBook, error) {
	setter := &MasterBookSetter{
		AuthorID: &author1.ID,
	}

	err := masterBook0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachMasterBookAuthor0: %w", err)
	}

	return masterBook0, nil
}

func (masterBook0 *MasterBook) InsertAuthor(ctx context.Context, exec bob.Executor, related *AuthorSetter) error {
	author1, err := Authors.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachMasterBookAuthor0(ctx, exec, 1, masterBook0, author1)
	if err != nil {
		return err
	}

	masterBook0.R.Author = author1

	author1.R.MasterBooks = append(author1.R.MasterBooks, masterBook0)

	return nil
}

func (masterBook0 *MasterBook) AttachAuthor(ctx context.Context, exec bob.Executor, author1 *Author) error {
	var err error

	_, err = attachMasterBookAuthor0(ctx, exec, 1, masterBook0, author1)
	if err != nil {
		return err
	}

	masterBook0.R.Author = author1

	author1.R.MasterBooks = append(author1.R.MasterBooks, masterBook0)

	return nil
}

func attachMasterBookPublisher0(ctx context.Context, exec bob.Executor, count int, masterBook0 *MasterBook, publisher1 *Publisher) (*MasterBook, error) {
	setter := &MasterBookSetter{
		PublisherID: &publisher1.ID,
	}

	err := masterBook0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachMasterBookPublisher0: %w", err)
	}

	return masterBook0, nil
}

func (masterBook0 *MasterBook) InsertPublisher(ctx context.Context, exec bob.Executor, related *PublisherSetter) error {
	publisher1, err := Publishers.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachMasterBookPublisher0(ctx, exec, 1, masterBook0, publisher1)
	if err != nil {
		return err
	}

	masterBook0.R.Publisher = publisher1

	publisher1.R.MasterBooks = append(publisher1.R.MasterBooks, masterBook0)

	return nil
}

func (masterBook0 *MasterBook) AttachPublisher(ctx context.Context, exec bob.Executor, publisher1 *Publisher) error {
	var err error

	_, err = attachMasterBookPublisher0(ctx, exec, 1, masterBook0, publisher1)
	if err != nil {
		return err
	}

	masterBook0.R.Publisher = publisher1

	publisher1.R.MasterBooks = append(publisher1.R.MasterBooks, masterBook0)

	return nil
}

func insertMasterBookRandokuImages0(ctx context.Context, exec bob.Executor, randokuImages1 []*RandokuImageSetter, masterBook0 *MasterBook) (RandokuImageSlice, error) {
	for i := range randokuImages1 {
		randokuImages1[i].MasterBookID = &masterBook0.ID
	}

	ret, err := RandokuImages.Insert(bob.ToMods(randokuImages1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertMasterBookRandokuImages0: %w", err)
	}

	return ret, nil
}

func attachMasterBookRandokuImages0(ctx context.Context, exec bob.Executor, count int, randokuImages1 RandokuImageSlice, masterBook0 *MasterBook) (RandokuImageSlice, error) {
	setter := &RandokuImageSetter{
		MasterBookID: &masterBook0.ID,
	}

	err := randokuImages1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachMasterBookRandokuImages0: %w", err)
	}

	return randokuImages1, nil
}

func (masterBook0 *MasterBook) InsertRandokuImages(ctx context.Context, exec bob.Executor, related ...*RandokuImageSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	randokuImages1, err := insertMasterBookRandokuImages0(ctx, exec, related, masterBook0)
	if err != nil {
		return err
	}

	masterBook0.R.RandokuImages = append(masterBook0.R.RandokuImages, randokuImages1...)

	for _, rel := range randokuImages1 {
		rel.R.MasterBook = masterBook0
	}
	return nil
}

func (masterBook0 *MasterBook) AttachRandokuImages(ctx context.Context, exec bob.Executor, related ...*RandokuImage) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	randokuImages1 := RandokuImageSlice(related)

	_, err = attachMasterBookRandokuImages0(ctx, exec, len(related), randokuImages1, masterBook0)
	if err != nil {
		return err
	}

	masterBook0.R.RandokuImages = append(masterBook0.R.RandokuImages, randokuImages1...)

	for _, rel := range related {
		rel.R.MasterBook = masterBook0
	}

	return nil
}

func insertMasterBookRandokuMemos0(ctx context.Context, exec bob.Executor, randokuMemos1 []*RandokuMemoSetter, masterBook0 *MasterBook) (RandokuMemoSlice, error) {
	for i := range randokuMemos1 {
		randokuMemos1[i].MasterBookID = &masterBook0.ID
	}

	ret, err := RandokuMemos.Insert(bob.ToMods(randokuMemos1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertMasterBookRandokuMemos0: %w", err)
	}

	return ret, nil
}

func attachMasterBookRandokuMemos0(ctx context.Context, exec bob.Executor, count int, randokuMemos1 RandokuMemoSlice, masterBook0 *MasterBook) (RandokuMemoSlice, error) {
	setter := &RandokuMemoSetter{
		MasterBookID: &masterBook0.ID,
	}

	err := randokuMemos1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachMasterBookRandokuMemos0: %w", err)
	}

	return randokuMemos1, nil
}

func (masterBook0 *MasterBook) InsertRandokuMemos(ctx context.Context, exec bob.Executor, related ...*RandokuMemoSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	randokuMemos1, err := insertMasterBookRandokuMemos0(ctx, exec, related, masterBook0)
	if err != nil {
		return err
	}

	masterBook0.R.RandokuMemos = append(masterBook0.R.RandokuMemos, randokuMemos1...)

	for _, rel := range randokuMemos1 {
		rel.R.MasterBook = masterBook0
	}
	return nil
}

func (masterBook0 *MasterBook) AttachRandokuMemos(ctx context.Context, exec bob.Executor, related ...*RandokuMemo) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	randokuMemos1 := RandokuMemoSlice(related)

	_, err = attachMasterBookRandokuMemos0(ctx, exec, len(related), randokuMemos1, masterBook0)
	if err != nil {
		return err
	}

	masterBook0.R.RandokuMemos = append(masterBook0.R.RandokuMemos, randokuMemos1...)

	for _, rel := range related {
		rel.R.MasterBook = masterBook0
	}

	return nil
}

func insertMasterBookSeidokuMemos0(ctx context.Context, exec bob.Executor, seidokuMemos1 []*SeidokuMemoSetter, masterBook0 *MasterBook) (SeidokuMemoSlice, error) {
	for i := range seidokuMemos1 {
		seidokuMemos1[i].MasterBookID = &masterBook0.ID
	}

	ret, err := SeidokuMemos.Insert(bob.ToMods(seidokuMemos1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertMasterBookSeidokuMemos0: %w", err)
	}

	return ret, nil
}

func attachMasterBookSeidokuMemos0(ctx context.Context, exec bob.Executor, count int, seidokuMemos1 SeidokuMemoSlice, masterBook0 *MasterBook) (SeidokuMemoSlice, error) {
	setter := &SeidokuMemoSetter{
		MasterBookID: &masterBook0.ID,
	}

	err := seidokuMemos1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachMasterBookSeidokuMemos0: %w", err)
	}

	return seidokuMemos1, nil
}

func (masterBook0 *MasterBook) InsertSeidokuMemos(ctx context.Context, exec bob.Executor, related ...*SeidokuMemoSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	seidokuMemos1, err := insertMasterBookSeidokuMemos0(ctx, exec, related, masterBook0)
	if err != nil {
		return err
	}

	masterBook0.R.SeidokuMemos = append(masterBook0.R.SeidokuMemos, seidokuMemos1...)

	for _, rel := range seidokuMemos1 {
		rel.R.MasterBook = masterBook0
	}
	return nil
}

func (masterBook0 *MasterBook) AttachSeidokuMemos(ctx context.Context, exec bob.Executor, related ...*SeidokuMemo) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	seidokuMemos1 := SeidokuMemoSlice(related)

	_, err = attachMasterBookSeidokuMemos0(ctx, exec, len(related), seidokuMemos1, masterBook0)
	if err != nil {
		return err
	}

	masterBook0.R.SeidokuMemos = append(masterBook0.R.SeidokuMemos, seidokuMemos1...)

	for _, rel := range related {
		rel.R.MasterBook = masterBook0
	}

	return nil
}

func insertMasterBookUserBookLogs0(ctx context.Context, exec bob.Executor, userBookLogs1 []*UserBookLogSetter, masterBook0 *MasterBook) (UserBookLogSlice, error) {
	for i := range userBookLogs1 {
		userBookLogs1[i].MasterBookID = &masterBook0.ID
	}

	ret, err := UserBookLogs.Insert(bob.ToMods(userBookLogs1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertMasterBookUserBookLogs0: %w", err)
	}

	return ret, nil
}

func attachMasterBookUserBookLogs0(ctx context.Context, exec bob.Executor, count int, userBookLogs1 UserBookLogSlice, masterBook0 *MasterBook) (UserBookLogSlice, error) {
	setter := &UserBookLogSetter{
		MasterBookID: &masterBook0.ID,
	}

	err := userBookLogs1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachMasterBookUserBookLogs0: %w", err)
	}

	return userBookLogs1, nil
}

func (masterBook0 *MasterBook) InsertUserBookLogs(ctx context.Context, exec bob.Executor, related ...*UserBookLogSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	userBookLogs1, err := insertMasterBookUserBookLogs0(ctx, exec, related, masterBook0)
	if err != nil {
		return err
	}

	masterBook0.R.UserBookLogs = append(masterBook0.R.UserBookLogs, userBookLogs1...)

	for _, rel := range userBookLogs1 {
		rel.R.MasterBook = masterBook0
	}
	return nil
}

func (masterBook0 *MasterBook) AttachUserBookLogs(ctx context.Context, exec bob.Executor, related ...*UserBookLog) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	userBookLogs1 := UserBookLogSlice(related)

	_, err = attachMasterBookUserBookLogs0(ctx, exec, len(related), userBookLogs1, masterBook0)
	if err != nil {
		return err
	}

	masterBook0.R.UserBookLogs = append(masterBook0.R.UserBookLogs, userBookLogs1...)

	for _, rel := range related {
		rel.R.MasterBook = masterBook0
	}

	return nil
}
